История языка Lua
Начало
Lua был разработан (или, точнее, выдвинут) комитетом; пусть и маленьким — всего с тремя членами, — но комитетом
Из слов разработчиков:
Наш первый опыт в TeCGraf (от пер. «группа технологий компьютерной графики Католического университета Рио-де-Жанейро в Бразилии»), связанный с разработкой своего ЯП, произошел в приложении для ввода данных. Инженерам PETROBRAS (бразильская нефтяная компания) по несколько раз в день требовалась подготовка файлов с исходными данными для симуляторов. 
Для упрощения разработки этого приложения в TeCGraf мы решили программировать все единообразно, разработав простой декларативный язык для описания всех задач по входным данным. Вот пример секции типичной программы на данном языке, названном нами DEL (data entry language):
Примерно в тоже время мы начали работать над другим проектом для PETROBRAS, названным PGM: настраиваемый генератор отчетов для литологических профилей. 
Все эти настройки задавались конечными пользователями, обычно геологами или инженерами, а программе следовало работать на небольших машинах, таких как PC с MS-DOS. Мы посчитали, что лучший способ настройки приложения возможен через специализированный язык описаний, который мы назвали Sol: акроним от Простой Объектный Язык (Simple Object Language), а заодно это переводилось с португальского как «солнце». 
В этот момент мы могли бы взять существующий язык, а не создавать еще один новый. Главными кандидатами были Tcl и, с большим отставанием, Forth и Perl. Perl — это не язык расширений. Плюс, в 1993 Tcl и Perl работали только на Unix платформах. Так же у всех трех языков сложный синтаксис. И ни один из них не имел хорошей поддержки описания данных. Так что мы начали работу над новым языком.
Так как язык был измененной версией Sol («солнце»), друг в TeCGraf предложил имя Lua («луна» по португальски), и так родился язык Lua.
Lua наследовал от Sol синтаксис записей и конструирования списков, но объединил их реализацию с использованием ассоциативных таблиц: записи использовали строки (имена полей) в качестве индексов; списки же использовали целочисленные индексы. Кроме этих возможностей описания данных в Lua не было новых концепций, так как нам был нужен легкий язык общего применения. Итак, мы начали с небольшого набора управляющих структур, синтаксис которых был заимствован из Modula(while, if, repeat until). Из CLU мы взяли множественное присваивание и возврат нескольких значений как результата вызова функции (значительно более понятный подход, чем in-out параметры или передача по ссылке). Из C++ мы взяли идею локальности области видимости переменных в месте их объявления.
Одной из небольших (даже мелких) инноваций был синтаксис конкатенации строк. Так как язык позволял неявное приведение строк к числам, использование оператора "+" было бы двусмысленным, то мы добавили синтаксис ".." (две точки) для такой операции.
Споры вызвало использование ";" (точки с запятой). Мы считали, что требование использования точки с запятой несколько запутает инженеров, знающих FORTRAN, с другой же стороны не использование ее запутает тех, кто знает C или Pascal. В конце концов, мы пришли к решению опциональности использования точки с запятой (типичное решение комитета).
Первоначально язык Lua имел семь типов данных: числа (хранящиеся в формате с плавающей точкой), строки, (ассоциативные) таблицы, nil (тип данных с уникальным значением так же названным nil), userdata (простой C'шный указатель для представления структур данных C внутри Lua), Lua функции и C функции. (Спустя восемь лет эволюции языка единственным изменением в этом списке стала лишь унификация Lua и С функций в единый тип). Для сохранения компактности языка мы не включили булевый тип данных. По аналогии с Lisp, nil приводится к false, тогда как все остальные значения приводятся к true. Это одна из немногих экономий о которой мы теперь иногда жалеем.
Lua также перенял из Sol подход к реализации в качестве библиотеки. Реализация следовала принципу, поддерживаемому сейчас Экстремальным Программированием: «самая простая реализация, которая может работать». Мы использовали lex для лексического сканера и yacc для синтаксического парсера. Парсер переводил программу в байткод, который затем выполнялся простым стековым интерпретатором. У языка была очень маленькая стандартная библиотека и было очень легко добавлять новые функции в C.
Несмотря на простую реализацию – или, возможно, из-за нее – Lua превзошел наши ожидания. Оба прокта (PGM и ED) успешно использовали Lua (а PGM все еще используется). В конце концов и остальные проекты в TeCGraf начали использовать Lua.
Первые годы (1994–1996)
Lua 1.0 не был публичным
У Lua 1.1 была ограниченная пользовательская лицензия
Lua 2.1, был свободным.
Lua версии 2
С самого начала мы разрабатывали Lua как язык расширений, в связи с чем программы на C могли регистрировать свои собственные функции, прозрачно вызываемые из Lua. С таким подходом было легко расширять Lua предметно-ориентированными примитивами, что позволяло конечному пользователю адаптировать язык под конкретные задачи.
В мае 1996 мы выпустили Lua 2.4. Основным нововведением этой новой версии был внешний компилятор, названный luac. Эта программа компилировала Lua код и сохраняла байткод и таблицы строк в бинарный файл. Кроме ускорения загрузки luac позволяет так же выполнять проверку синтаксиса при компиляции и защиту исходного кода от изменений пользователем. Однако предварительная компиляция не ускоряет выполнение, так как Lua и так всегда предварительно компилирует исходный код перед выполнением.
luac реализован в «режиме клиента», то есть он использует модули, реализующие Lua как с простого клиента, даже не смотря на то, что используются приватные заголовочные файлы для доступа ко внутренним структурам данных, требующих сохранения. Одним преимуществом такой политики является разделение реализации ядра Lua на четко разделенные модули. Благодаря этому, сейчас легко удалить модули парсинга (лексер, парсер и кодогенератор), занимающие 40% кода ядра Lua 4.0, оставив лишь крошечный модуль загрузки предварительно скомпилированных фрагментов кода. Это может быть полезно для очень маленьких реализация Lua для встраивания в небольшие устройства вроде мобильных телефонов или роботов (к примеру, Crazy Ivan, робот побеждавший в RoboCup в 2000 и 2001 в Германии, имел «мозги» реализованные на Lua).
Представление миру (1996–2000)
В июне 1996 мы опубликовали академическую статью про Lua в Software: Practice & Experience (от пер. по ссылке скачивание за денежку. нашел в другом месте судя по всему тот же самый материал и конвертнул в pdf, если кому интересно). В декабре 1996 журнал Dr. Dobb's опубликовал статью про Lua. Данные публикации, нацеленные на разные сообщества, привели к международной известности Lua.
Оказалось, что Bret Mogilefsky был ведущим программистом Grim Fandango, основной адвенчуры LucasArts в 1997 году. В другом письме он пишет нам, что «ОГРОМНАЯ часть игры написана на Lua» (акцент авторский). Это первое использование Lua в игре привлекло к языку внимание множества игровых разработчиков во всем мире. Спустя некоторое время Lua все чаще стал появляться в игровых группах новостей вроде rec.games.programmer и comp.ai.games.
Вследствие небольшого размера, хорошей производительности, переносимости и простоты интеграции Lua приобрел большую популярность для расширения функционала игр. В наше время некоторые игровые компании применяют Lua (к примеру LucasArts, BioWare, Slingshot Game Technology и Loewen Entertainment) и знание Lua является конкурентным преимуществом при поиске работы в игровой индустрии. По нашей оценке половина пользователей Lua вовлечены в разработку игр, но сложно посчитать точнее из-за большой секретности в игровой индустрии. К примеру, хоть Bret Mogilefsky и адаптировал Lua для Grim Fandango, но подробности не доступны публике.
Встраивание скриптового языка в игру дает несколько преимуществ. Скриптовый язык можно использовать для описания спрайтов и физики объектов, управления AI и персонажем, а так же для взаимодействия с устройствами ввода. К примеру, движок может ничего не знать о таких вещах, как «урон», «скорость», «оружие», и т.п. Выбор простого языка позволяет игровым дизайнерам использовать программируемые инструменты. Это крайне важно для разработки игр, так как позволяет дизайнерам экспериментировать с их творениями. Скриптовые языки также способствуют быстрому прототипированию и облегчают реализацию отладчиков.
Не так давно, в 2000, LucasArts выпустили другую игру, использующую Lua, Escape from Monkey Island, которая была четвертой в серии адвенчур Monkey Island. В этой игре в дань уважения Lua авторы переименовали внутриигровой бар из SCUMM (ранее используемый разработчиками язык программирования) в Бар Lua.
Помимо широкого использования в компьютерных играх (к примеру, Grim Fandango, Baldur's Gate, MDK2, Escape from Monkey Island) Lua используется во многих других сферах по всему миру.
Одним из первых мест применений Lua вне PUC-Rio (от пер. тот самый католический университет Рио-де-Жанейро, подразделением которого является TeCGraf) была Смитсоновская астрофизическая обсерватория. Они разработали обобщенную программу апертуры для имитации воздействия потока фотонов на физические препятствия. Данная программа была частью усилий по продвижению программы AXAF (объект продвинутой рентгеновской астрофизики) — третьей из четырех Великий Космических Обсерваторий NASA.
Performance Technologies использовали Lua для реализации интерфейса командной строки для CPC4400 — ethernet свич с возможностью горячей замены. Используя Lua в качестве скриптового языка для CPC4400, пользователь может связывать происходящие события (такие как статус соединения, изменения топологии, тревоги RMON) со скриптами на Lua.
Tollgrade Communications использовали Lua в их продукте нового поколения для тестирования телефонной сети DigiTest. Lua использовался для пользовательского интерфейса, автоматизированных тестовых скриптов и результатов анализа.
Lua так же используется в InCor Heart Institute (Instituto do Coracao, Sao Paulo) в Бразилии, в CEPEL(иследовательский центр государственной электроэнергетической компании ELETROBRAS) так же в Бразилии, в Weierstrass Institute в Берлине, в берлинском техническом университете, и во множестве других мест.
В 1998 Cameron Laird и Kathryn Soraiz в их колонке про скриптовые языки в журнале SunWorld подсчитали, что «в мире где-то около нескольких сотен тысяч Lua программистов». По их мнению это «небольшое число пользователей», но для нас это явный знак к росту популярности языка.
Lua версии 3
В Lua 3.0 так же появилась поддержка условной компиляции в формате похожего на C препроцессора. Как и любая языковая возможность, добавить эту было очень легко (хоть это и усложнило лексер), и вскоре программисты начали ее использовать (программисты используют любые возможности языка). При появлении нового функционала, сразу растет спрос на его дальнейшее развитие. Одним из самых частых запросов было добавление макросов, но продолжительное обсуждение так и не вылилось в четкое предложение ни в списке рассылок, ни между нами. Каждое из предложений требовало огромных изменений в лексере и парсере, не показывая при этом явной выгоды. Так что препроцессор оставался статичным с Lua 3.0 и до версии 3.2 (в течение двух лет).
В конце концов мы решили, что препроцессор причинял больше вреда, чем приносил пользы, делая код громоздким и заманивая пользователей в бесконечные обсуждения, и удалили его в Lua 4.0. И без препроцессора Lua стал чище. На протяжении лет мы стремились сделать Lua проще и удалить темные углы языка, которые мы когда-то считали новыми возможностями, но которые использовались лишь редкими программистами, а в последствии и вообще стали считаться ошибками.

Заключение
Сейчас у Lua устоявшаяся пользовательская база. Активен список рассылки почти на 500 человек из более чем 30 различных стран мира. На сайте (www.lua.org) примерно 500 посетителей в день из 50 стран. Язык используют в спектре от адвенчур до веб-сверверов и до тестирования телефонной сети для Ethernet свичей.
Несколько ftp серверов предлагают исходные коды Lua, а также несколько других сайтов распространяют версии для конкретных платформ, таких как DLL для Windows, SIS для EPOC, RPM для Linux, бинарники для RISC OS, и т.д. Более того, некоторые журналы распространяют Lua на добавочных CD дисках (к примеру Dr. Dobb's, Linux Magazine France и японский C Magazine).
Основной вклад Lua как языка заключается в предоставлении мета-механизмов вместо функциональности. Успех Lua как продукта пришел из его простоты, небольшого размера и портируемости реализации, позволивших использовать Lua на множестве различных платформ, включая небольшие устройства вроде palm'ов, КПК, специализированных плат и роботов. Cameron Laird и Kathryn Soraiz предсказали в 1998, что «неизбежный взрыв повсеместного использования встраиваемых устройств (компьютеров в вашей машине, ванной, и кухонной технике) может пойти лишь на пользу Lua». Тогда мы не обратили на это особого внимания, но они были правы.
Также Lua внес вклад в академическую деятельность благодаря нескольким тезисам и публикациям как о самом языке, так и о его технологическом использовании.
Успех имеет свою цену. В процессе эволюции языка обратная совместимость все сильнее сдерживала инновации. Тем не менее, мы не позволяли совместимости остановить прогресс — это лишь один из многих ингредиентов (пусть даже и сильный) в алхимии дизайна языков.
Наконец, удержать язык — это гораздо больше, чем просто разработать его. Всецелое внимание к деталям важно во всех аспектах: дизайне языка, создании сообщества пользователей и прислушивания к их словам, придерживаясь в тоже время исходных проектных решений.


